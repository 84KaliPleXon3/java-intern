<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		<title>Intern: The user guide</title>
		<link rel="shortcut icon" href="images/favicon.png" type="image/png">
		<link rel="stylesheet" href="css/main.css">
		<script src="//use.typekit.net/cbd5jmj.js"></script>
		<script>try{Typekit.load({active:function(){window.fontsActivated=true;window.onTypekitActive&&window.onTypekitActive();}});}catch(e){}</script>
		<script>
(function () {
	var test = document.createElement('b');
	for (var prefix in { '': 1, '-webkit-': 1 }) {
		var position = prefix + 'sticky';
		test.style.position = position;
		if (test.style.position === position) {
			return;
		}
	}
	document.documentElement.classList.add('no-sticky');
})();
		</script>
	</head>
	<body>
		<span role="button" id="showMenu" class="icon-menu"
			aria-controls="tableOfContents"
			aria-expanded="false"
			tabindex="0"
			title="Table of contents">Menu</span>
		<header class="header">
			<div class="wrapper">
				<div class="preTitle">
					<a class="logo" href="https://theintern.github.io/intern/"></a>
					<nav id="mainMenu">
						<ul>
							<li><a href="http://theintern.io">About</a></li>
							<li><a href="https://theintern.github.io/leadfoot/">Leadfoot</a></li>
							<li><a href="https://theintern.github.io/digdug/">Dig Dug</a></li>
							<li><a href="https://github.com/theintern/intern/">GitHub</a></li>
						</ul>
					</nav>
				</div>
				<div id="initialScrollPoint">
					<form action="https://duckduckgo.com/" role="search">
						<input type="hidden" name="sites" value="theintern.github.io">
						<label class="search">
							<input type="text" name="q">
							<span class="icon-search"></span>
						</label>
					</form>
					<h1 class="title">Intern. The user guide</h1>
				</div>
				<script>
(function () {
	if (window.scrollY === 0 && !location.hash && !document.documentElement.classList.contains('no-sticky')) {
		document.documentElement.style.minHeight = (window.innerHeight + /* $lh */ 32) + 'px';
		var scrollTo = document.getElementById('initialScrollPoint');
		window.scrollTo(window.scrollX, scrollTo.getBoundingClientRect().top);
	}
})();
				</script>
			</div>
		</header>

		<div class="content">
			<div class="wrapper">
				<nav class="nav" id="tableOfContents">
					<ul>
						<li data-id="fundamentals">
							<a href="#fundamentals">Fundamentals</a>
							<ul class="subsections">
								<li data-id="what-is-intern"><a href="#what-is-intern">What is Intern?</a></li>
								<li data-id="system-requirements"><a href="#system-requirements">System requirements</a></li>
								<li data-id="reading-guide"><a href="#reading-guide">Reading this guide</a></li>
								<li data-id="directory-structure"><a href="#directory-structure">Recommended directory structure</a></li>
							</ul>
						</li>
						<li data-id="getting-started">
							<a href="#getting-started">Getting started</a>
							<ul class="subsections">
								<li data-id="fundamentals-overview"><a href="#fundamentals-overview">Overview</a></li>
								<li data-id="installation"><a href="#installation">Installation</a></li>
								<li data-id="terminology"><a href="#terminology">Terminology</a></li>
								<li data-id="conventions"><a href="#conventions">Conventions</a></li>
								<li data-id="first-app"><a href="#first-app">Testing your first app</a></li>
							</ul>
						</li>
						<li data-id="configuration">
							<a href="#configuration">Configuration</a>
							<ul class="subsections">
								<li data-id="common-config"><a href="#common-config">Common configuration</a></li>
								<li data-id="client-config"><a href="#client-config">Client-specific configuration</a></li>
								<li data-id="runner-config"><a href="#runner-config">Runner-specific configuration</a></li>
							</ul>
						</li>
						<li data-id="interfaces">
							<a href="#interfaces">Test interfaces</a>
							<ul class="subsections">
								<li data-id="interface-overview"><a href="#interface-overview">Overview</a></li>
								<li data-id="interface-object"><a href="#interface-object">The Object interface</a></li>
								<li data-id="interface-tdd"><a href="#interface-tdd">The TDD &amp; BDD interfaces</a></li>
							</ul>
						</li>
						<li data-id="unit-testing">
							<a href="#unit-testing">Unit testing</a>
							<ul class="subsections">
								<li data-id="writing-unit-test"><a href="#writing-unit-test">Writing a unit test</a></li>
								<li data-id="async-lifecycle"><a href="#async-lifecycle">Asynchronous lifecycle methods</a></li>
								<li data-id="testing-commonjs-code"><a href="#testing-commonjs-code">Testing non-AMD code</a></li>
								<li data-id="testing-global-code"><a href="#testing-global-code">Testing non-modular code</a></li>
								<li data-id="testing-other-module"><a href="#testing-other-module">Testing other transpiled code</a></li>
							</ul>
						</li>
						<li data-id="functional-testing">
							<a href="#functional-testing">Functional testing</a>
							<ul class="subsections">
								<li data-id="writing-functional-test"><a href="#writing-functional-test">Writing a functional test</a></li>
								<li data-id="leadfoot-api"><a href="#leadfoot-api">The Leadfoot API</a></li>
								<li data-id="page-objects"><a href="#page-objects">Page objects</a></li>
								<li data-id="native-apps"><a href="#native-apps">Testing native apps</a></li>
							</ul>
						</li>
						<li data-id="webdriver-server">
							<a href="#webdriver-server">Getting a WebDriver server</a>
							<ul class="subsections">
								<li data-id="local-selenium"><a href="#local-selenium">Local Selenium</a></li>
								<li data-id="hosted-selenium"><a href="#hosted-selenium">Cloud hosting</a></li>
								<li data-id="selenium-grid"><a href="#selenium-grid">Selenium Grid</a></li>
							</ul>
						</li>
						<li data-id="execution-modes">
							<a href="#execution-modes">Running tests</a>
							<ul class="subsections">
								<li data-id="browser-client"><a href="#browser-client">The browser client</a></li>
								<li data-id="node-client"><a href="#node-client">The Node.js client</a></li>
								<li data-id="test-runner"><a href="#test-runner">The test runner</a></li>
							</ul>
						</li>
						<li data-id="reporters">
							<a href="#reporters">Getting test results</a>
							<ul class="subsections">
								<li data-id="reporter-overview"><a href="#reporter-overview">Overview</a></li>
								<li data-id="reporter-results"><a href="#reporter-results">Test results reporters</a></li>
								<li data-id="reporter-lcov"><a href="#reporter-lcov">Code coverage reporters</a></li>
							</ul>
						</li>
						<li>
							<a href="#ci">Continuous integration</a>
							<ul class="subsections">
								<li data-id="ci-jenkins"><a href="#ci-jenkins">Jenkins</a></li>
								<li data-id="ci-travis"><a href="#ci-travis">Travis CI</a></li>
								<li data-id="ci-teamcity"><a href="#ci-teamcity">TeamCity</a></li>
							</ul>
						</li>
						<li>
							<a href="#customisation">Customisation</a>
							<ul class="subsections">
								<li data-id="custom-interfaces"><a href="#custom-interfaces">Custom interfaces</a></li>
								<li data-id="custom-executors"><a href="#custom-executors">Custom executors</a></li>
								<li data-id="custom-reporters"><a href="#custom-reporters">Custom reporters</a></li>
							</ul>
						</li>
						<li>
							<a href="#internals">Internals</a>
							<ul class="subsections">
								<li data-id="suite-object"><a href="#suite-object">The Suite object</a></li>
								<li data-id="test-object"><a href="#test-object">The Test object</a></li>
							</ul>
						</li>
						<li>
							<a href="#community">Community</a>
							<ul class="subsections">
								<li data-id="getting-help"><a href="#getting-help">Getting help</a></li>
								<li data-id="contributing"><a href="#contributing">Contributing</a></li>
							</ul>
						</li>
					</ul>

					<p class="support"><a href="https://sitepen.com/support/index.html">Commercial support</a></p>
				</nav>

				<main class="main" id="main">
					<article>
						<div class="a" id="fundamentals"></div>
						<h2 data-id="fundamentals">Fundamentals</h2>

						<div class="a half" id="what-is-intern"></div>
						<h3 data-id="what-is-intern">What is Intern?</h3>

						<p></p>

						<aside class="whatAreYouCrazy"><p>Hey, you found the new user guide! This document is still a work in progress as we try to migrate and expand upon the content already in the <a href="https://github.com/theintern/intern/wiki">Intern wiki</a>. Not everything here is accurate yet, and there’s a lot that’s still missing, but please feel free to take a look!</p></aside>

						<p>Intern is a complete framework for testing Web sites and applications. It’s built around standards like WebDriver and was designed from the ground up to be the most powerful, flexible, and reliable JavaScript testing system in the world.</p>

						<p>Intern can test all sorts of things:</p>

						<ul>
							<li>Plain JavaScript code, in any module format (or no module format!)</li>
							<li>Web pages generated by server-side languages (like Java, PHP, or Ruby)</li>
							<li>Native or hybrid iOS and Android applications</li>
						</ul>

						<p>Intern is minimally prescriptive and enforces only a basic set of best practices designed to ensure your tests stay maintainable over time. Its extensible architecture allows you to write custom test interfaces, executors, and reporters to influence how your tests run &amp; easily integrate with your existing coding environment.</p>

						<p>Intern also comes with Grunt tasks so it can be quickly added to existing Grunt-based workflows, and is designed to work out-of-the-box with many popular continuous integration services like Jenkins and Travis CI.</p>

						<p>Intern is used by companies large and small, including some you may have heard of, like Aerohive Networks, Esri, HSBC, IBM, ING, Intuit, Marriott, Mozilla, Stripe, and Twitter. We hope you’ll enjoy working with it too!</p>

						<h4>Who is Intern best for?</h4>

						<p>Intern is best for development teams that want a complete, flexible, <a href="TODO">standards-based</a>, high-quality testing solution that Just Works. It’s best for testing JavaScript code, but it is also an excellent tool for testing server-generated Web pages or native mobile apps. Its built-in <a href="TODO">support for source maps</a> makes it uniquely well-suited for developers that compile their code to JavaScript from another language, or that run tests against production-ready built/minified code.</p>

						<p>Intern is excellent for teams that are just beginning to write tests; its built-in <a href="TODO">code coverage analysis</a> makes thorough testing fast and precise, and its <a href="TODO">functional testing system</a> enables testing of highly procedural code that’s other impossible to test.</p>

						<p>Intern is a great choice if you’re hoping to transition away from your current testing library but already have a lot of tests, since its <a href="TODO">extensible interfaces</a> make it possible to transition without needing to rewrite tests or learn a totally new set of APIs.</p>

						<p>Intern’s execution model is especially well-suited to those that follow a test-last development approach and want to prevent regressions using continuous integration. It has also been used very successfully by teams that follow a test-driven development approach.</p>

						<p>Finally, because of its strong architectural patterns, conventions, and expansive feature set, Intern is especially well-suited for testing extremely large, “enterprise-level” applications that must be maintained by large teams of developers with varying skill levels.</p>

						<div class="a half" id="system-requirements"></div>
						<h3 data-id="system-requirements">System requirements</h3>

						<p>Intern can be used to run unit tests in any of the following environments:</p>

						<table>
							<tr>
								<td>Android Browser</td>
								<td>4.1+</td>
							</tr>
							<tr>
								<td>Chrome</td>
								<td>31+</td>
							</tr>
							<tr>
								<td>Firefox</td>
								<td>17+</td>
							</tr>
							<tr>
								<td>Internet Explorer</td>
								<td>9+</td>
							</tr>
							<tr>
								<td>Node.js/io.js</td>
								<td>0.10+</td>
							</tr>
							<tr>
								<td>Opera</td>
								<td>26+</td>
							</tr>
							<tr>
								<td>Safari (iOS)</td>
								<td>6.1+</td>
							</tr>
							<tr>
								<td>Safari (Mac OS)</td>
								<td>6.0+</td>
							</tr>
						</table>

						<p>Intern can be used to run functional tests in any of the following environments:</p>

						<table>
							<tr>
								<td>Android (browser, hybrid, native)</td>
								<td>4.1+</td>
							</tr>
							<tr>
								<td>Chrome</td>
								<td>31+</td>
							</tr>
							<tr>
								<td>Firefox</td>
								<td>17+</td>
							</tr>
							<tr>
								<td>Internet Explorer</td>
								<td>8+</td>
							</tr>
							<tr>
								<td>iOS (browser, hybrid, native)</td>
								<td>6.1+</td>
							</tr>
							<tr>
								<td>Opera</td>
								<td>26+</td>
							</tr>
							<tr>
								<td>Safari (Mac OS)</td>
								<td>6+</td>
							</tr>
						</table>

						<p>All other environments are not currently officially supported, but should work as long as they correctly implement EcmaScript 5 (for unit tests) and/or WebDriver (for functional tests).</p>

						<p>In order to execute functional tests, or to execute tests against multiple browsers at the same time, Intern also requires Node.js/io.js 0.10+ plus a WebDriver-compatible server.</p>

						<p>The following WebDriver servers are compatible with Intern:</p>

						<table>
							<tr>
								<td>Appium</td>
								<td>1.3.0+</td>
							</tr>
							<tr>
								<td>ChromeDriver</td>
								<td>2.9+</td>
							</tr>
							<tr>
								<td>FirefoxDriver (Selenium)</td>
								<td>2.41.0+</td>
							</tr>
							<tr>
								<td>InternetExplorerDriver (Selenium)</td>
								<td>2.41.0+</td>
							</tr>
							<tr>
								<td>ios-driver</td>
								<td>0.6.6+</td>
							</tr>
							<tr>
								<td>SafariDriver (Selenium)</td>
								<td>2.41.0+</td>
							</tr>
							<tr>
								<td>Selendroid</td>
								<td>0.9.0+</td>
							</tr>
						</table>

						<p>Intern also integrates with cloud hosted services from <a href="https://browserstack.com">BrowserStack</a>, <a href="https://saucelabs.com">Sauce Labs</a>, and <a href="https://testingbot.com">TestingBot</a>.</p>

						<div class="a half" id="reading-guide"></div>
						<h3 data-id="reading-guide">Reading this guide</h3>

						<p>Throughout this guide, you will find certain pieces of information are called out specifically, as we have found them to be especially important or problematic for users.</p>

						<aside class="tip">
							<p>Sections that look like this contain advanced tips and tricks that can help you get the most out of Intern.</p>
						</aside>

						<aside class="deprecated">
							<p>Sections that look like this tell you about functionality that is deprecated and will be removed from a future version of Intern.</p>
						</aside>

						<aside class="whatAreYouCrazy">
							<p>Sections that look like this tell you about dangerous anti-patterns that can break, slow down, or make your code less maintainable.</p>
						</aside>

						<p>Later sections of this guide are designed to be built upon knowledge presented in earlier parts. If you jump into the middle and feel confused, step back a section or two until you find the information you need to move forward. We also accept <a href="https://github.com/theintern/intern/pulls?q=is%3Aopen+label%3Adocumentation+is%3Apr">pull requests</a> to the documentation in order to improve its flow and clarity.</p>

						<div class="a half" id="directory-structure"></div>
						<h3 data-id="directory-structure">Recommended directory structure</h3>

						<p>While Intern can be used to test code using nearly any directory structure, if you are starting a new project or have the ability to modify the directory structure of your existing project, a few small changes can help make Intern integration a lot easier.</p>

						<p>The recommended directory structure for a front-end or front+back-end project using Intern looks like this:</p>

						<pre>project_root/
	dist/         – (optional) Built code; mirrors the `src` directory
	node_modules/ – Node.js dependencies, including Intern
		intern/
	src/          – Front-end source code (+ browser dependencies)
		app/        – Your application code
		index.html  – Your application entry point
	tests/        – Intern tests
		functional/ – Functional tests
		support/    – Test support files
		              (custom interfaces, reporters, mocks, etc.)
		unit/       – Unit tests
		intern.js   – Intern configuration</pre>

						<p>Using this directory structure provides a few benefits:</p>

						<ul>
							<li>It lets you easily switch from testing source and built code simply by changing the location of your packages from <kbd>src</kbd> to <kbd>dist</kbd> in your Intern configuration</li>
							<li>It lets you use the default loader <code>baseUrl</code> configuration setting without worrying about path differences between Node.js and browser</li>
							<li>It adds another layer of assurance that your tests and other private server-side code won’t be accidentally deployed along with the rest of your application</li>
						</ul>
					</article>

					<article>
						<div class="a" id="getting-started"></div>
						<h2 data-id="getting-started">Getting started</h2>

						<div class="a half" id="fundamentals-overview"></div>
						<h3 data-id="fundamentals-overview">Overview</h3>

						<figure>
							<img src="http://placekitten.com/1000/608">
							<figcaption>The architecture of Intern</figcaption>
						</figure>

						<p>Intern provides two strategies for automated testing: unit testing and functional testing.</p>

						<p><dfn>Unit testing</dfn> works by executing a piece of code directly and inspecting the result. For example, calling a function and then checking that it returns an expected value is a form of unit testing. This is the most common and most useful form of testing for day-to-day development, since it’s very fast and allows very small units of code to be tested in isolation. However, unit tests are limited to only testing certain testable code designs, and can also be limited by the constraints of the execution environment (like browser sandboxes).</p>

						<p><dfn>Functional testing</dfn> works by issuing commands to a device that mimic actual user interactions. Once an interaction has occurred, these tests verify that the expected information is displayed by the user interface. Because these interactions come from outside the application being tested, they are not restricted by the execution environment. They also allow application code to be treated as a black box, which means functional tests can be written to test pages and applications written in any language. Because functional tests don’t call any APIs directly, code that is unable to be unit tested can still be successfully exercised. Functional tests allow the automation of UI &amp; integration testing that would otherwise need to be performed manually.</p>

						<p>By understanding &amp; combining both of these testing strategies when testing an application, it becomes possible to effectively automate nearly all of the QA process, enabling much faster development cycles and significantly reducing software defects.</p>

						<div class="a half" id="installation"></div>
						<h3 data-id="installation">Installation</h3>

						<p>Intern can be installed simply by running <kbd>npm install intern</kbd>.</p>

						<div class="a half" id="terminology"></div>
						<h3 data-id="terminology">Terminology</h3>

						<p>Intern uses certain standard terminology in order to make it easier to understand each part of the system.</p>

						<ul>
							<li>An <dfn><a href="TODO">assertion</a></dfn> is a function call that verifies that a variable contains (or a function returns) an expected, correct, value (e.g. <code>assert.isTrue(someVariable, 'someVariable should be true')</code>)</li>
							<li>A <dfn>test <a href="#interfaces">interface</a></dfn> is a programming interface for registering tests with Intern</li>
							<li>A <dfn>test case</dfn> (or, just <dfn>test</dfn>) is a function that makes calls to application code and makes assertions about what it should have done</li>
							<li>A <dfn>test suite</dfn> is a collection of tests (and, optionally, sub–test-suites) that are related to each other in some logical way</li>
							<li>A <dfn>test module</dfn> is a JavaScript module, usually in <a href="#amd">AMD format</a>, that contains test suites</li>
						</ul>

						<p>These pieces can be visualized in a hierarchy, like this:</p>

						<ul>
							<li>
								test module
								<ul>
									<li>
										test suite
										<ul>
											<li>
												test suite
												<ul>
													<li>
														test case
														<ul>
															<li>...</li>
														</ul>
													</li>
													<li>...</li>
												</ul>
											</li>
											<li>
												test case
												<ul>
													<li>assertion</li>
													<li>assertion</li>
													<li>...</li>
												</ul>
											</li>
											<li>...</li>
										</ul>
									</li>
									<li>test suite</li>
									<li>...</li>
								</ul>
							</li>
							<li>test module</li>
							<li>...</li>
						</ul>

						<div class="a half" id="conventions"></div>
						<h3 data-id="conventions">Conventions</h3>

						<p>Intern follows certain conventions in order to make testing easier and more reliable. Understanding these fundamental concepts will help you get the most out of testing with Intern.</p>

						<h4>Asynchronous operations</h4>

						<p>Intern always uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> objects whenever an asynchonous operation is required to complete an action. All <a href="TODO">suite</a>, <a href="TODO">test</a>, and <a href="TODO">reporter</a> functions can return a Promise, which will pause the test system until the Promise resolves (or until a timeout occurs, whichever happens first).</p>

						<h4 id="amd">Module loader &amp; format</h4>

						<p>Intern is built on top of a standard <abbr title="Asynchronous Module Definition">AMD</abbr> loader, which means that its modules are also normally written in the AMD module format. Using an AMD loader instead of something like the built-in Node.js loader + Browserify is, in fact, critical to providing a highly stable and flexible testing system.</p>

						<p>AMD is the only stable standard for module loading that has all of these traits:</p>

						<ul>
							<li>Allows modules to be written for the browser without <em>requiring</em> an intermediate compilation step;</li>
							<li>Allows modules and other assets to be <em>asynchronously</em> or <em>conditionally</em> resolved by writing simple <a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">loader plugins</a>;</li>
							<li>Allows “hard-coded” dependencies of modules under test to be <a href="TODO">mocked</a> without messing with the internals of the module loader</li>
						</ul>

						<p>Because the AMD standard includes the ability to run loader plugins, it’s not necessary for your test modules to be written as AMD modules if you don’t want. Just write a loader plugin that understands the module format you prefer and you’re ready to go!</p>

						<p>Once the <a href="http://jrburke.com/2015/02/13/how-to-know-when-es-modules-are-done/">outstanding issues with native ES modules</a> have been addressed, and a native module loader with equivalent capabilities to a standard AMD loader is available on all the platforms supported by Intern, it will be rewritten to use the native module format, but no earlier.</p>

						<pre><code class="javascript">function TODO() {}</code></pre>

						<figure>
							<pre><code class="javascript">function TODO() {}</code></pre>
							<figcaption>TODO</figcaption>
						</figure>

						<div class="codeMirror">
							<pre><code class="javascript">function TODO() {}</code></pre>
							<pre class="align-bottom"><samp class="javascript">output</samp></pre>
						</div>

						<div class="a half" id="first-app"></div>
						<h3 data-id="first-app">Testing your first app</h3>

						<p>TODO: Take content from intern-tutorial.</p>
					</article>

					<article>
						<div class="a" id="configuration"></div>
						<h2 data-id="configuration">Configuration</h2>

						<div class="a half" id="common-config"></div>
						<h3 data-id="common-config">Common configuration</h3>

						<p>Intern’s configuration files are actually <a href="http://dojotoolkit.org/documentation/tutorials/1.10/modules/">standard AMD modules</a> that export a configuration object. This allows simple inheritance of parent configurations and enables test configurations to be generated programmatically at runtime.</p>
						<p>The module ID to load is specified using the <a href="#argument-config"><kbd>config</kbd> argument</a> on the command-line (for Node.js) or the <kbd>config</kbd> argument in the URL query-string (for browsers).</p>

						<aside class="tip"><p>Take a look at the <a href="https://github.com/theintern/intern/blob/master/tests/example.intern.js">example configuration file</a> that comes with Intern to learn what a valid configuration looks like.</p></aside>

						<p>The following configuration options are common to <a href="#execution-modes">all execution modes</a> in Intern:</p>

						<table>
							<thead>
								<tr>
									<th>Option</th>
									<th>Type</th>
									<th>Default</th>
								</tr>
							</thead>
							<tr>
								<th scope="row"><a href="#option-grep">grep</a></th>
								<td>A regular expression that filters which tests should run.</td>
								<td><code class="javascript">/.*/</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-loader">loader</a></th>
								<td>Configuration options for the AMD loader.</td>
								<td><code class="javascript">{ … }</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-reporters">reporters</a></th>
								<td>An array of reporters to use to report test results.</td>
								<td><code class="javascript">[ 'runner' ]</code> (runner)<br><code class="javascript">[ 'console' ]</code> (client)</td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-suites">suites</a></th>
								<td>An array of of unit test module IDs to load.</td>
								<td><code class="javascript">[]</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-useLoader">useLoader</a></th>
								<td>An alternative module loader to use in place of the built-in AMD loader.</td>
								<td><code class="javascript">{}</code></td>
							</tr>
						</table>

						<div class="a half" id="option-grep"></div>
						<h4>grep (RegExp)</h4>

						<p>A regular expression that filters which tests should run. <code>grep</code> should be used whenever you want to run only a subset of all available tests.</p>

						<p>When using <code>grep</code>, its value is matched against the ID of each registered test, and tests that don’t match are skipped with a skip message of “grep”.</p>

						<p>The ID of a test is a concatenation of the test’s name, plus the names of its parent suites, separated by <code>' - '</code>. In other words, a test registered like this:</p>

						<pre><code class="javascript">tdd.suite('FooComponent', function () {
	tdd.test('startup', function () {
		// ...
	});
});</code></pre>

						<p>…would have the ID <code>'FooComponent - startup'</code>. In this case, all of the following <code>grep</code> values would match and cause this test to run:</p>

						<ul>
							<li><code class="javascript">/FooComponent/</code></li>
							<li><code class="javascript">/startup/</code></li>
							<li><code class="javascript">/FooComponent - startup/</code></li>
							<li><code class="javascript">/foocomponent/i</code></li>
							<li><code class="javascript">/start/</code></li>
						</ul>

						<p>The following <code>grep</code> values would <em>not</em> match and cause this test to be skipped:</p>

						<ul>
							<li><code class="javascript">/BarComponent/</code> – “BarComponent” is not in the full name of the test</li>
							<li><code class="javascript">/foocomponent/</code> – this regular expression is case sensitive</li>
							<li><code class="javascript">/^startup/</code> – the full ID of the test is matched, not just the name part</li>
						</ul>

						<div class="a half" id="option-loader"></div>
						<h4>loader (Object)</h4>

						<p>Configuration options for the module loader. Any <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md">configuration options</a> that are supported by the active loader can be used here. By default, the <a href="https://github.com/dojo/dojo2">Dojo 2</a> AMD loader is used; this can be changed to another loader that provides an AMD-compatible API with <a href="#config-useLoader"><code>useLoader</code></a>.</p>

						<p>AMD configuration options supported by the built-in loader are <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md#map-"><code>map</code></a>, <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md#packages-"><code>packages</code></a>, and <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md#paths-"><code>paths</code></a>.</p>

						<p><a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md#baseurl-"><code>baseUrl</code></a> is automatically set according to the current environment:</p>

						<ul>
							<li>In Node.js client mode and runner mode, <code>baseUrl</code> is set to the current working directory specified by <code>process.cwd()</code></li>
							<li>In browser client mode, <code>baseUrl</code> is set to the directory two path segments above the directory containing client.html</li>
						</ul>

						<p>When following the <a href="TODO">recommended filesystem layout</a>, a typical loader configuration will look like this:</p>

						<pre><code class="javascript">{
	loader: {
		packages: [
			{ name: 'app', location: 'src/' },
			{ name: 'tests', location: 'tests/' }
		]
	}
}</code></pre>

						<p>If you are testing an AMD application and need to use stub modules for testing, the <code>map</code> configuration option is the correct way to do this:</p>

						<pre><code class="javascript">{
	loader: {
		map: {
			app: {
				// When any module inside 'app' tries to load 'app/foo',
				// it will receive 'tests/stubs/app/foo' instead
				'app/foo': 'tests/stubs/app/foo'
			}
		}
	}
}</code></pre>

						<div class="a half" id="option-reporters"></div>
						<h4>reporters (Array&lt;string>)</h4>

						<p>An array of reporters to use to report test results. Reporters in this list can either be <a href="#reporters">built-in reporter names</a> (like <code class="javascript">'console'</code> or <code class="javascript">'junit'</code>), or absolute AMD module IDs (like <code class="javascript">'tests/support/customReporter'</code>) when using <a href="#custom-reporters">custom reporters</a>.</p>

						<p>If reporters are not specified in the configuration, Intern will pick defaults that are most suitable for the current execution mode.</p>

						<div class="a half" id="option-suites"></div>
						<h4>suites (Array&lt;string>)</h4>

						<p>An array of unit test module IDs to load. For example:</p>

						<pre><code class="javascript">{
	suites: [
		'tests/unit/foo',
		'tests/unit/bar'
	]
}</code></pre>

						<p>Because the same configuration file is used on the client, where there is no filesystem access, there is currently no built-in way to glob for test modules. Future versions of Intern will not have this restriction when running in Node.js client or runner mode.</p>

						<p><code>suites</code> can also be set to <code class="javascript">null</code> to skip loading the unit testing system when in runner mode.</p>

						<div class="a half" id="option-useLoader"></div>
						<h4>useLoader (Object)</h4>

						<p>An alternative module loader to use in place of the built-in AMD loader. When <code>useLoader</code> is specified, Intern will swap out the built-in loader with the loader you’ve specified before loading reporters and test modules.</p>

						<p>The alternative loader you use must implement the AMD API and must support the <code>baseUrl</code>, <code>map</code>, and <code>packages</code> configuration options.</p>

						<p>There are two different keys that may be specified so that the correct path to the loader can be provided in each environment:</p>

						<ul>
							<li><code>host-node</code> specifies the loader to use in Node.js. This should be a Node.js module ID.</li>
							<li><code>host-browser</code> specifies the loader to use in browsers. This should be a URL to a script file.</li>
						</ul>

						<p>Loader paths are relative to the directory where Intern is installed.</p>

						<p>For example, to use a copy of RequireJS installed to the same project as Intern:</p>

						<pre><code class="javascript">useLoader: {
	'host-node': 'requirejs',
	'host-browser': '../../node_modules/requirejs/require.js'
}</code></pre>

						<div class="a half" id="client-config"></div>
						<h3 data-id="client-config">Client-specific configuration</h3>

						<p>Certain configuration options only apply when in client mode. These options are ignored when running in runner mode.</p>

						<table>
							<thead>
								<tr>
									<th>Option</th>
									<th>Type</th>
									<th>Default</th>
								</tr>
							</thead>
							<tr>
								<th scope="row"><a href="#option-baseUrl">baseUrl</a></th>
								<td>The path to use when converting module IDs to URLs, relative to client.html.</td>
								<td><code class="javascript">'../..'</code></td>
							</tr>
						</table>

						<div class="a half" id="option-capabilities"></div>
						<h4>baseUrl (string)</h4>

						<p>The path to use when converting module IDs to URLs, relative to client.html. Since browsers do not have any concept of a current working directory, using this argument allows a pseudo-cwd to be specified for the browser client in order to match up file paths with what exists on the underlying filesystem.</p>

						<aside class="tip"><p>This argument is only available when loading the browser client; for the Node.js client, the current working directory is always used as the base path for loading modules.</p></aside>

						<div class="a half" id="runner-config"></div>
						<h3 data-id="runner-config">Runner-specific configuration</h3>

						<p>Certain configuration options only apply when in runner mode. These options are ignored when running in client mode.</p>

						<table>
							<thead>
								<tr>
									<th>Option</th>
									<th>Type</th>
									<th>Default</th>
								</tr>
							</thead>
							<tr>
								<th scope="row"><a href="#option-capabilities">capabilities</a></th>
								<td>Default capabilities for all test environments.</td>
								<td>
									<code class="javascript">{ name: configModuleId,<br>  'idle-timeout': 60 }</code>
								</td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-environments">environments</a></th>
								<td>An array of capabilities objects, one for each desired test environment.</td>
								<td><code class="javascript">[]</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-excludeInstrumentation">excludeInstrumentation</a></th>
								<td>A regular expression matching paths to exclude from code coverage.</td>
								<td><code class="javascript">null</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-functionalSuites">functionalSuites</a></th>
								<td>An array of functional test module IDs to load.</td>
								<td><code class="javascript">[]</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-maxConcurrency">maxConcurrency</a></th>
								<td>The maximum number of environments to test simultaneously.</td>
								<td><code class="javascript">3</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-proxyPort">proxyPort</a></th>
								<td>The port where the Intern HTTP server will listen for requests.</td>
								<td><code class="javascript">9000</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-proxyUrl">proxyUrl</a></th>
								<td>The external URL to the Intern HTTP server.</td>
								<td><code class="javascript">'http://localhost:9000/'</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-tunnel">tunnel</a></th>
								<td>The tunnel to use to establish a WebDriver server for testing.</td>
								<td><code class="javascript">'NullTunnel'</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-tunnelOptions">tunnelOptions</a></th>
								<td>Options to pass to the WebDriver server tunnel.</td>
								<td><code class="javascript">{}</code></td>
							</tr>
						</table>

						<div class="a half" id="option-capabilities"></div>
						<h4>capabilities (Object)</h4>

						<p>Default capabilities for all test environments. These baseline capabilities are extended for each environment by the <a href="#option-environments"><code>environments</code></a> array.</p>

						<p>Different services like BrowserStack and Sauce Labs may have different sets of available capabilities. In order for Intern to work correctly, it’s important that you use the appropriate capabilities for WebDriver server you are interacting with:</p>

						<ul>
							<li><a href="https://code.google.com/p/selenium/wiki/DesiredCapabilities">Selenium capabilities</a></li>
							<li><a href="https://www.browserstack.com/automate/capabilities">BrowserStack capabilities</a></li>
							<li><a href="https://docs.saucelabs.com/reference/test-configuration/#webdriver-api">Sauce Labs capabilities</a> and <a href="https://saucelabs.com/platforms">environments</a></li>
							<li><a href="https://testingbot.com/support/other/test-options">TestingBot capabilities</a> and <a href="https://testingbot.com/support/getting-started/browsers.html">environments</a></li>
						</ul>

						<p>Extra <a href="https://sites.google.com/a/chromium.org/chromedriver/capabilities">options for ChromeDriver</a> are specified on the <code>chromeOptions</code> capability.</p>

						<p>Intern will automatically fill certain capabilities fields in order to provide better feedback within cloud service dashboards:</p>

						<ul>
							<li><code>name</code> will be set to the ID of the configuration file being used</li>
							<li><code>build</code> will be set to the commit ID from the <code>TRAVIS_COMMIT</code> and <code>BUILD_TAG</code> environment variables, if either exists</li>
						</ul>

						<div class="a half" id="option-environments"></div>
						<h4>environments (Array&lt;Object>)</h4>

						<p>An array of capabilities objects, one for each desired test environment. The same options from <a href="#option-capabilities">capabilities</a> are used for each environment specified in the array. To delete an option from the default capabilities, explicitly set its value to <code class="javascript">undefined</code>.</p>

						<p>If arrays are provided for <code>browserName</code>, <code>version</code>, <code>platform</code>, or <code>platformVersion</code>, all possible option permutations will be generated. For example:</p>

						<pre><code class="javascript">{
	environments: [
		{
			browserName: 'chrome',
			version: [ '23', '24' ],
			platform: [ 'Linux', 'Mac OS 10.8' ]
		}
	]
}</code></pre>

						<p>This configuration will generate 4 environments: Chrome 23 on Linux, Chrome 23 on Mac OS 10.8, Chrome 24 on Linux, and Chrome 24 on Mac OS 10.8.</p>

						<p>All other capabilities are not permuted, but are simply passed as-is to the WebDriver server.</p>

						<p>Different cloud testing services use different capability values when specifying environment capabilities. For example, Sauce Labs uses 'Windows XP' to specify the Windows XP platform while BrowserStack uses 'XP'. Check <a href="#options-capabilities">the list above</a> to find the right capabilities for your chosen platform.</p>

						<div class="a half" id="option-excludeInstrumentation"></div>
						<h4>excludeInstrumentation (RegExp)</h4>

						<p>A regular expression matching paths to exclude from code coverage. The regular expression matches the path-part of URLs (starting from the end of <a href="#option-proxyUrl">proxyUrl</a>, excluding any trailing slash) that should not be instrumented for code coverage during testing.</p>

						<p>This option should be used when you want to exclude dependencies from being reported in your code coverage results. (Intern code—that is, anything that loads from {{proxyUrl}}/__intern/—is always excluded from code coverage results.) For example, to exclude tests and Node.js dependencies from being reported in your application’s code coverage analysis:</p>

						<pre><code class="javascript">{
	excludeInstrumentation: /^(?:tests|node_modules)\//
}</code></pre>

						<div class="a half" id="option-functionalSuites"></div>
						<h4>functionalSuites (Array&lt;string>)</h4>

						<p>An array of functional test module IDs to load. <a href="TODO">Functional tests</a> are different from unit tests because they are executed on the local (Node.js) side, not the remote (browser) side, so they are specified separately from the list of unit test modules.</p>

						<pre><code class="javascript">{
	functionalSuites: [
		'tests/functional/foo',
		'tests/functional/bar'
	]
}</code></pre>

						<div class="a half" id="option-maxConcurrency"></div>
						<h4>maxConcurrency (number)</h4>

						<p>The maximum number of environments to test simultaneously. Set this to <code class="javascript">Infinity</code> to run tests against all environments at once. You may want to reduce this if you have a limited number of test machines available, or are using a shared hosted account.</p>

						<div class="a half" id="option-proxyPort"></div>
						<h4>proxyPort (number)</h4>

						<p>The port where the Intern HTTP server will listen for requests. Intern’s HTTP server performs two critical tasks:</p>

						<ul>
							<li>Automatically adds instrumentation to your JavaScript code so that it can be analysed for completeness by the code coverage reporter</li>
							<li>Provides a communication conduit for the unit testing system to provide live test results in runner mode</li>
						</ul>

						<p>Any JavaScript code that you want to evaluate for code coverage must either pass through the code coverage proxy or be <a href="TODO">pre-instrumented</a> for Intern. The HTTP server must also be accessible to the environment (browser) being tested in runner mode in order for unit testing results to be transmitted back to the test runner successfully.</p>

						<div class="a half" id="option-proxyUrl"></div>
						<h4>proxyUrl (string)</h4>

						<p>The external URL to the Intern HTTP server. You will need to change this value only if you are running Intern’s HTTP server through a reverse proxy, or if Intern’s HTTP server needs to be reached through a public interface that your Selenium servers can access directly.</p>

						<p>TODO: Link to more info about reverse proxying/testing dynamic endpoints/CORS</p>

						<div class="a half" id="option-tunnel"></div>
						<h4>tunnel (string)</h4>

						<p>The tunnel to use to establish a WebDriver server for testing. The tunnel can either be a <a href="https://theintern.github.io/digdug/">built-in tunnel name</a> (like <code class="javascript">'NullTunnel'</code> or <code class="javascript">'BrowserStackTunnel'</code>), or an absolute AMD module ID (like <code class="javascript">'tests/support/CustomTunnel'</code>) when using a custom tunnel.</p>


						<p>The following tunnels are built in to Intern:</p>

						<ul>
							<li><a href="https://theintern.github.io/digdug/BrowserStackTunnel.html">BrowserStackTunnel</a> – For use with <a href="https://browserstack.com">BrowserStack</a></li>
							<li><a href="https://theintern.github.io/digdug/NullTunnel.html">NullTunnel</a> – For use with any other WebDriver server</li>
							<li><a href="https://theintern.github.io/digdug/SauceLabsTunnel.html">SauceLabsTunnel</a> – For use with <a href="https://saucelabs.com">Sauce Labs</a></li>
							<li><a href="https://theintern.github.io/digdug/TestingBotTunnel.html">TestingBotTunnel</a> – For use with <a href="https://testingbot.com">TestingBot</a></li>
						</ul>

						<p>When you are using your own Selenium server or Selenium grid, you will typically use the <code class="javascript">'NullTunnel'</code> tunnel and specify the <code>host</code>, <code>port</code>, and/or <code>path</code> to the Selenium server in <a href="#option-tunnelOptions">tunnelOptions</a>.</p>

						<div class="a half" id="option-tunnelOptions"></div>
						<h4>tunnelOptions (Object)</h4>

						<p>Options to pass to the WebDriver server tunnel. Valid options for each of the built-in tunnels can be found in the <a href="https://theintern.github.io/digdug/">Dig Dug documentation</a>, linked to from <a href="#option-tunnel">the list above</a>.</p>
					</article>

					<article>
						<div class="a" id="interfaces"></div>
						<h2 data-id="interfaces">Test interfaces</h2>

						<div class="a half" id="interface-overview"></div>
						<h3 data-id="interface-overview">Overview</h3>

						<p>TODO</p>

						<div class="a half" id="interface-object"></div>
						<h3 data-id="interface-object">The Object interface</h3>

						<p>The Object interface is the most basic API for writing tests. It exposes a single function, usually referenced as <code>registerSuite</code>. This function is used to register a series of tests by passing in a plain JavaScript object containing test functions:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');

	registerSuite({
		name: 'Suite name',

		setup: function () {
			// executes before suite starts;
			// can also be called `before` instead of `setup`
		},

		teardown: function () {
			// executes after suite ends;
			// can also be called `after` instead of `teardown`
		},

		beforeEach: function () {
			// executes before each test
		},

		afterEach: function () {
			// executes after each test
		},

		'Test foo': function () {
			// a test case
		},

		'Test bar': function () {
			// another test case
		},

		/* … */
	});
});</code></pre>

						<p>If you need to hold variables that are modified by test suites, it’s important to pass a function to <code>registerSuite</code> and create the variables inside that function, instead of putting the variables directly inside the factory:</p>

						<pre><code class="javascript">define(function (require) {
	var assert = require('intern/chai!assert');
	var registerSuite = require('intern!object');

	// Don't put this here! This variable is shared!
	var counter = 0;

	registerSuite({
		name: 'Anti-pattern',

		setup: function () {
			app = {
				id: counter++
			};
		},

		'Test the id': function () {
			// May or may not be true! The value of `counter`
			// may have been modified by another suite execution!
			assert.strictEqual(app.id, counter - 1);
		}
	});
});</code></pre>

						<pre><code class="javascript">define(function (require) {
	var assert = require('intern/chai!assert');
	var registerSuite = require('intern!object');

	registerSuite(function () {
		// Do put this here! This variable is unique for each environment!
		var counter = 0;

		return {
			name: 'Correct pattern',

			setup: function () {
				app = {
					id: counter++
				};
			},

			'Test the id': function () {
				// The value of `counter` will always be what is expected
				assert.strictEqual(app.id, counter - 1);
			}
		};
	});
});</code></pre>

						<aside class="whatAreYouCrazy"><p>Failure to follow this guidance will cause extremely unpredictable test execution, but <em>only</em> once you start running functional tests against multiple environments concurrently using the <a href="#test-runner">test runner</a>! This defect will be invisible when running tests against a single environment or when running with <a href="#option-maxConcurrency">maxConcurrency</a> set to 1.</p></aside>

						<p>It is also possible to nest suites by using an object as a value instead of a function:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');

	registerSuite({
		name: 'Suite name',

		'Test foo': function () {
			// a test case
		},

		// this is a sub-suite, not a test
		'Sub-suite name': {
			// it can also have its own suite lifecycle methods
			setup: function () { /* … */ },
			teardown: function () { /* … */ },
			beforeEach: function () { /* … */ },
			afterEach: function () { /* … */ },

			'Sub-suite test': function () {
				// a test case inside the sub-suite
			},

			'Sub-sub-suite name': {
				// and so on…
			}
		},

		/* … */
	});
});</code></pre>

						<div class="a half" id="interface-tdd"></div>
						<h3 data-id="interface-tdd">The TDD &amp; BDD interfaces</h3>

						<p>The TDD &amp; BDD interfaces are nearly identical to each other, differing only slightly in the names of the properties that they expose. Registering suites and tests using the TDD &amp; BDD interfaces is more procedural than the <a href="#interface-object">Object interface</a>:</p>

						<pre><code class="javascript">define(function (require) {
	var tdd = require('intern!tdd');

	tdd.suite('Suite name', function () {
		tdd.before(function () {
			// executes before suite starts
		});

		tdd.after(function () {
			// executes after suite ends
		});

		tdd.beforeEach(function () {
			// executes before each test
		});

		tdd.afterEach(function () {
			// executes after each test
		});

		tdd.test('Test foo', function () {
			// a test case
		});

		tdd.test('Test bar', function () {
			// another test case
		});

		// …
	});
</code></pre>

						<p>The BDD interface attempts to enforce a more literary, behaviour-describing convention for suites and tests by using different names for its registration functions:</p>

						<pre><code class="javascript">define(function (require) {
	var bdd = require('intern!bdd');

	bdd.describe('the thing being tested', function () {
		bdd.before(function () {
			// executes before suite starts
		});

		bdd.after(function () {
			// executes after suite ends
		});

		bdd.beforeEach(function () {
			// executes before each test
		});

		bdd.afterEach(function () {
			// executes after each test
		});

		bdd.it('should do foo', function () {
			// a test case
		});

		bdd.it('should do bar', function () {
			// another test case
		});

		// …
	});
});</code></pre>

						<aside class="tip"><p>Both interfaces work the same, so just pick which style you prefer and stick with it!</p></aside>

						<p>Just like the Object interface, the TDD &amp; BDD interfaces allow suites to be nested by calling <code>tdd.suite</code> or <code>bdd.describe</code> from within a parent suite:</p>

						<pre><code class="javascript">define(function (require) {
	var tdd = require('intern!tdd');

	tdd.suite('Suite name', function () {
		tdd.test('Test foo', function () {
			// a test case
		});

		tdd.suite('Sub-suite name', function () {
			// it can also have its own suite lifecycle methods
			tdd.before(function () { /* … */ });
			tdd.after(function () { /* … */ });
			tdd.beforeEach(function () { /* … */ });
			tdd.afterEach(function () { /* … */ });

			tdd.test('Sub-test name', function () {
				// a test case inside the sub-suite
			});

			tdd.suite('Sub-sub-suite', function () {
				// and so on…
			})
		});

		// …
	});
</code></pre>

						<aside class="whatAreYouCrazy"><p>Don’t try to call <code>tdd.suite</code> or <code>bdd.describe</code> from inside a test case; it’s not supported.</p></aside>
					</article>

					<article>
						<div class="a" id="unit-testing"></div>
						<h2 data-id="unit-testing">Unit testing</h2>

						<div class="a half" id="writing-unit-test"></div>
						<h3 data-id="writing-unit-test">Writing a unit test</h3>

						<p>TODO</p>

						<div class="a half" id="async-lifecycle"></div>
						<h3 data-id="async-lifecycle">Asynchronous lifecycle methods</h3>

						<p>TODO</p>

						<div class="a half" id="testing-commonjs-code"></div>
						<h3 data-id="testing-commonjs-code">Testing CommonJS modules</h3>

						<p>TODO</p>

						<div class="a half" id="testing-global-code"></div>
						<h3 data-id="testing-global-code">Testing non-modular code</h3>

						<p>TODO</p>

						<div class="a half" id="testing-other-module"></div>
						<h3 data-id="testing-other-module">Testing other transpiled code</h3>

						<p>TODO</p>
					</article>

					<article>
						<div class="a" id="functional-testing"></div>
						<h2 data-id="functional-testing">Functional testing</h2>

						<div class="a half" id="writing-functional-test"></div>
						<h3 data-id="writing-functional-test">Writing a functional test</h3>

						<p>TODO</p>

						<div class="a half" id="leadfoot-api"></div>
						<h3 data-id="leadfoot-api">The remote object API</h3>

						<p>TODO</p>

						<div class="a half" id="page-objects"></div>
						<h3 data-id="page-objects">Page objects</h3>

						<p>TODO</p>

						<div class="a half" id="native-apps"></div>
						<h3 data-id="native-apps">Testing native apps</h3>

						<p>TODO</p>
					</article>

					<article>
						<div class="a" id="webdriver-server"></div>
						<h2 data-id="webdriver-server">Getting a WebDriver server</h2>

						<div class="a half" id="local-selenium"></div>
						<h3 data-id="local-selenium">Local Selenium</h3>

						<p>TODO</p>

						<div class="a half" id="hosted-selenium"></div>
						<h3 data-id="hosted-selenium">Cloud hosting</h3>

						<p>TODO</p>

						<div class="a half" id="selenium-grid"></div>
						<h3 data-id="selenium-grid">Selenium Grid</h3>

						<p>TODO</p>
					</article>

					<article>
						<div class="a" id="execution-modes"></div>
						<h2 data-id="execution-modes">Running tests</h2>

						<div class="a half" id="browser-client"></div>
						<h3 data-id="browser-client">The browser client</h3>

						<p>The browser client allows unit tests to be run directly in a browser without any server other than a regular HTTP server. This is useful when you are in the process of writing unit tests that require a browser, or when you need to run a debugger in the browser to inspect a test failure.</p>

						<p>The browser client is loaded by navigating to <code>intern/client.html</code>. Assuming an Intern configuration file is located at <code>my-project/tests/intern</code>, a typical execution that runs all unit tests would look like this:</p>

						<pre><samp>http://localhost/my-project/node_modules/intern/client.html?
	config=tests/intern</samp></pre>

						<aside class="whatAreYouCrazy"><p>The <code>config</code> argument is a module ID, not a file path. Providing a file path may cause confusing or unpredictable results.</p></aside>

						<p>As can be seen from this example, because there is no concept of a “working directory” in URLs, the browser client chooses the directory two levels above <code>client.html</code> to be the root directory for the current test run. This can be overridden by specifying a <code>baseUrl</code> argument:</p>

						<pre><samp>http://localhost/my-project/node_modules/intern/client.html?
	baseUrl=/&amp;
	config=my-project/tests/intern</samp></pre>

						<aside class="whatAreYouCrazy"><p>Modifying the <code>baseUrl</code> anywhere within the test system can lead to confusing path problems. For best results, use the <a href="#directory-structure">recommended directory structure</a>.</p></aside>

						<p>Additional arguments to the browser client can be put in the query string. A more complex execution with arguments overriding the <a href="#option-suites">suites</a> and <a href="#option-reporters">reporters</a> properties from the configuration file might look like this:</p>

						<pre><samp>http://localhost/my-project/node_modules/intern/client.html?
	config=tests/intern&amp;
	suites=tests/unit/request&amp;
	suites=tests/unit/animation&amp;
	reporters=console&amp;
	reporters=html</samp></pre>

						<aside class="tip"><p>The browser client is also used by the <a href="#test-runner">test runner</a> to run unit tests in each browser.</p></aside>

						<div class="a half" id="node-client"></div>
						<h3 data-id="node-client">The Node.js client</h3>

						<p>The Node.js client allows unit tests to be run directly within a local Node.js or io.js environment. This is useful when you are writing unit tests for code that runs in Node.js/io.js. It is invoked by running <kbd>intern-client</kbd> on the command-line.</p>

						<p>A typical execution that runs all tests and outputs results to the console would look like this:</p>

						<pre><samp class="bash">intern-client config=tests/intern</samp></pre>

						<aside class="whatAreYouCrazy"><p>The <code>config</code> argument is a module ID, not a file path. Providing a file path may cause confusing or unpredictable results.</p></aside>

						<aside class="tip"><p>When running on Windows, all command-line options must be surrounded by quotes.</p></aside>

						<aside class="tip"><p>The commands shown above rely on npm being installed and configured properly. If your environment PATH is not set properly, you may need to run <kbd>node_modules/.bin/intern-client</kbd> instead of <kbd>intern-client</kbd>.</p></aside>

						<p>A more complex execution with arguments overriding the <a href="#options-suites">suites</a> and <a href="#option-reporters">reporters</a> properties from the configuration file might look like this:</p>

						<pre><samp class="bash">intern-client config=tests/intern suites=tests/unit/request \
	suites=tests/unit/animation \
	reporters=console \
	reporters=lcovhtml</samp></pre>

						<div class="a half" id="test-runner"></div>
						<h3 data-id="test-runner">The test runner</h3>

						<p>The test runner allows functional tests to be executed against a Web browser or native mobile application. It also allows unit tests &amp; functional tests to be executed on multiple environments at the same time. This is useful when you want to automate UI testing, or when you want to run your entire test suite against multiple environments at once (for example, in <a href="#ci">continuous integration</a>). It is invoked by running <kbd>intern-runner</kbd> on the command-line.</p>

						<p>In order to use the test runner, you will need a WebDriver server. The WebDriver server is responsible for providing a way to control to all of the environments that you want to test. You can get a WebDriver server in one of a few different ways:</p>

						<ul>
							<li><a href="#local-selenium">By installing a copy of Selenium on your local machine</a></li>
							<li><a href="#hosted-selenium">By getting an account with a cloud-hosted Selenium provider</a></li>
							<li><a href="#selenium-grid">By setting up a distributed Selenium Grid</a></li>
						</ul>

						<p>A typical execution that runs all tests against all <a href="#option-environments">environments</a> and outputs aggregate test &amp; code coverage results to the console would look like this:</p>

						<pre><samp class="bash">intern-runner config=tests/intern</samp></pre>

						<aside class="whatAreYouCrazy"><p>The <code>config</code> argument is a module ID, not a file path. Providing a file path may cause confusing or unpredictable results.</p></aside>

						<aside class="tip"><p>When running on Windows, all command-line options must be surrounded by quotes.</p></aside>

						<aside class="tip"><p>The commands shown above rely on npm being installed and configured properly. If your environment PATH is not set properly, you may need to run <kbd>node_modules/.bin/intern-runner</kbd> instead of <kbd>intern-runner</kbd>.</p></aside>

						<p>A more complex execution that overrides the <a href="#option-reporters">reporters</a> and <a href="#option-functionalSuites">functionalSuites</a> properties from the configuration file might look like this:</p>

						<pre><samp class="bash">intern-runner config=tests/intern \
	reporters=runner reporters=lcovhtml \
	functionalSuites=tests/functional/home \
	functionalSuites=tests/functional/cart</samp></pre>

						<aside class="tip"><p>The test runner is the <em>only</em> executor that runs functional tests.</p></aside>

						<div class="a half" id="test-runner-code-coverage"></div>
						<h4>Using the test runner as a code coverage instrumenting HTTP server</h4>

						<p>The test runner always creates an HTTP server to provide a conduit for communication with browsers, and to instrument code for code coverage analysis on-the-fly. The test runner can be set to Proxy Only mode, which causes it to simply start the instrumenting server and then wait until it is killed by <kbd>Ctrl+C</kbd>. This can be useful when you want to run the <a href="#browser-client">browser client</a> manually and get access to code coverage information, which is not available when running the browser client directly from a normal HTTP server.</p>

						<p>To run in Proxy Only mode, simply run <kbd>intern-runner</kbd> with the <a href="TODO">proxyOnly</a> flag:</p>

						<pre><samp class="bash">intern-runner config=tests/intern proxyOnly</samp></pre>

						<p>Once the server is running, it can be accessed at the port specified by <a href="#option-proxyPort">proxyPort</a> in the configuration file. The current working directory will be served as the root of the server.</p>
					</article>

					<article>
						<div class="a" id="reporters"></div>
						<h2 data-id="reporters">Getting test results</h2>

						<div class="a half" id="reporter-overview"></div>
						<h3 data-id="reporter-overview">Overview</h3>

						<p>TODO</p>

						<div class="a half" id="reporter-results"></div>
						<h3 data-id="reporter-results">Test results reporters</h3>

						<p>TODO</p>

						<div class="a half" id="reporter-lcov"></div>
						<h3 data-id="reporter-lcov">Code coverage reporters</h3>

						<p>TODO</p>
					</article>

					<article>
						<div class="a" id="ci"></div>
						<h2 data-id="ci">Continuous integration</h2>

						<div class="a half" id="ci-jenkins"></div>
						<h3 data-id="ci-jenkins">Jenkins</h3>

						<p>When integrating Intern with Jenkins, there are two primary ways in which the integration can be completed: either creating a new project that executes as a post-build action for your primary project using a shared workspace, or by creating a multi-step free-style software project that executes Intern after the first (existing) build step.</p>

						<p>For projects that are already using Maven, a third option is to execute Intern using <a href="http://mojo.codehaus.org/exec-maven-plugin/"><code>exec-maven-plugin</code></a> from an existing <code>pom.xml</code>.</p>

						<p>When using Intern with Jenkins, use the <code>junit</code> reporter and enable the “Publish JUnit test result report” post-build action for the best test results display.</p>

						<p>To add code coverage data to Jenkins, add the <code>cobertura</code> reporter, install the Cobertura plugin for Jenkins, and enable the “Publish Cobertura Coverage Report” post-build action.</p>

						<h4>Intern as a post-build action to an existing project</h4>

						<p>This option enables you to use an existing build project by adding a new project that executes unit tests in a separate job from the main build. This option is ideal for situations where you want to be able to manage the build and testing processes separately, or have several projects that need to be built downstream from the main project that can occur in parallel with test execution.</p>

						<p>In order to accomplish this efficiently without the need to copy artifacts, use of the Shared Workspace plugin is recommended. To install and configure the Shared Workspace plugin, follow these steps:</p>

						<ol>
							<li>Install the Shared Workspace plugin from the Jenkins → Manage Jenkins → Manage Plugins page.</li>
							<li>Go to the Jenkins → Manage Jenkins → Configure System page.</li>
							<li>Under Workspace Sharing, add a new shared workspace. For the purposes of these instructions, this shared workspace will be called “myApp”.</li>
							<li>Save changes.</li>
						</ol>

						<p>Once the Shared Workspace plugin is installed, all projects that need to share the same workspace must be updated. The shared workspace for each project can be selected from the first section of the project’s configuration page.</p>

						<p>Once the main project is set to use the shared workspace, the new unit test project should be created:</p>

						<ol>
							<li>Create a new free-style software project, e.g. “myApp-tests”.</li>
							<li>At the top of the configuration, change the shared workspace to “myApp-tests”.</li>
							<li>Under “Source Code Management”, leave the “None” option checked. Because of the shared workspace, source code checkout will be handled by the upstream project.</li>
							<li>Under “Build triggers”, check the “Build after other projects are built” checkbox. Enter the name of the existing Maven project in the text box that appears. (This will create a corresponding post-build action to build “myApp-tests” in the existing project’s configuration.)</li>
							<li>Under “Build”, click the “Add build step” button and choose “Execute shell” from the drop-down.</li>
							<li>Under “Execute shell”, enter the command you want to use to run Intern. See the <a class="internal present" href="/theintern/intern/wiki/Running-Intern">Running tests</a> section for possible commands.</li>
							<li>Save changes.</li>
						</ol>

						<p>Once this project has been configured, test everything by running a build on the main project. Once the main project build finishes successfully, the new “myApp-tests” project will begin executing automatically.</p>

						<h4>Intern as part of a free-style software project</h4>

						<p>When working with an existing free-style software project it is possible to simply add the unit testing as an extra build step, following steps similar to the above:</p>

						<ol>
							<li>Open the configuration page for the existing free-style software project.</li>
							<li>Under “Build”, click the “Add build step” button and choose “Execute shell” from the drop-down.</li>
							<li>Under “Execute shell”, enter the command you want to use to run Intern. See the <a href="#runnin-intern">Running tests</a> section for possible commands.</li>
							<li>Save changes.</li>
						</ol>

						<h4>Intern as an execution step in a Maven pom.xml</h4>

						<p>Intern can be executed by Maven from a <code>pom.xml</code> during the test or integration-test phases of the build by using the <code>exec-maven-plugin</code> to spawn a new Intern process:</p>

						<pre><code class="xml">&lt;plugin>
	&lt;artifactId>exec-maven-plugin&lt;/artifactId>
	&lt;groupId>org.codehaus.mojo&lt;/groupId>
	&lt;version>1.2.1&lt;/version>
	&lt;executions>
			&lt;execution>
			&lt;id>run-tests&lt;/id>
			&lt;phase>test&lt;/phase>
			&lt;goals>
				&lt;goal>exec&lt;/goal>
			&lt;/goals>
		&lt;/execution>
	&lt;/executions>
	&lt;configuration>
		&lt;executable>node_modules/.bin/intern-runner&lt;/executable>
		&lt;arguments>
			&lt;argument>config=tests/intern&lt;/argument>
		&lt;/arguments>
	&lt;/configuration>
&lt;/plugin></code></pre>

						<p>The <code>executable</code> and <code>arguments</code> elements should be modified to run Intern using your desired executor and configuration.</p>

						<div class="a half" id="ci-travis"></div>
						<h3 data-id="ci-travis">Travis CI</h3>

						<p>In order to enable <a href="http://travis-ci.org/">Travis CI</a> builds for your project, you must first create a <code>.travis.yml</code> in your repository root that will load and execute Intern:</p>

						<pre><code class="hljs yaml"><span class="hljs-attribute">language:</span> <span class="hljs-value">node_js</span>
<span class="hljs-attribute">node_js:</span>
	- <span class="hljs-string">'0.10'</span>
<span class="hljs-attribute">script:</span> <span class="hljs-value">node_modules/.bin/intern-runner config=tests/intern</span></code></pre>

						<aside class="tip"><p>If you are using a cloud hosting provider like BrowserStack, Sauce Labs, or TestingBot, you can add <a href="TODO">environment variables</a> holding your access credentials either through the Travis CI Web site by going to the repository’s settings page, or by <a href="http://docs.travis-ci.com/user/environment-variables/">adding an <code>env</code> list</a> to your .travis.yml configuration.</p></aside>

						<p>Once you have a Travis configuration, you just need to actually start the thing:</p>

						<ol>
							<li>Go to <a href="https://travis-ci.org/">https://travis-ci.org/</a></li>
							<li>Click “Sign in with GitHub” at the top-right</li>
							<li>Allow Travis CI to access your GitHub account</li>
							<li>Go to <a href="https://travis-ci.org/profile">https://travis-ci.org/profile</a></li>
							<li>Click “Sync now”, if necessary, to list all your GitHub projects</li>
							<li>Click the on/off switch next to the repository you want to test</li>
						</ol>

						<p>The next time you push commits to the repository, you will be able to watch Intern happily execute all your tests directly from the Travis CI Web site. Any time you make a new commit, or a new pull request is issued, Travis will automatically re-run your test suite and send notification emails on failure.</p>

						<div class="a half" id="ci-teamcity"></div>
						<h3 data-id="ci-teamcity">TeamCity</h3>

						<p>There are two primary ways that Intern can be integrated with a <a href="http://www.jetbrains.com/teamcity/">TeamCity</a> project: either by adding a new build configuration that is chained using a post-build trigger, or by adding additional build steps to an existing build configuration.</p>

						<p>When using Intern with TeamCity, use Intern’s <code>teamcity</code> reporter for best integration.</p>

						<h4>Intern as an additional build step</h4>

						<ol>
							<li>Go to the project that you want to add Intern to and click “Edit Project Settings” at the top-right.</li>
							<li>In the left-hand menu, click “General Settings”.</li>
							<li>Under “Build Configurations”, click “Edit” on the existing build configuration you want to add Intern to.</li>
							<li>In the left-hand menu, click “Build Steps”.</li>
							<li>Click “Add build step”.</li>
							<li>Select “Command Line” from the “Runner type” drop-down.</li>
							<li>Enter a name like “Run Intern” as the step name.</li>
							<li>Select “Custom Script” from the “Run” drop-down.</li>
							<li>Under “Custom script”, enter the command you want to use to run Intern. See the <a href="#running-intern">Running tests</a> section for possible commands.</li>
							<li>Click “Save”.</li>
						</ol>

						<h4>Intern as a separate build configuration</h4>

						<ol>
							<li>Go to the project that you want to add Intern to and click “Edit Project Settings” at the top-right.</li>
							<li>In the left-hand menu, click “General Settings”.</li>
							<li>Under “Build Configurations”, click “Create build configuration”.</li>
							<li>Enter a name like “Intern” as the build configuration name.</li>
							<li>Click “Save”.</li>
							<li>In the left-hand menu, click “Build Steps”.</li>
							<li>Click “Add build step”.</li>
							<li>Select “Command Line” from the “Runner type” drop-down.</li>
							<li>Enter a name like “Run Intern” as the step name.</li>
							<li>Select “Custom Script” from the “Run” drop-down.</li>
							<li>Under “Custom script”, enter the command you want to use to run Intern. See the <a href="#running-intern">Running tests</a> section for possible commands.</li>
							<li>Click “Save”.</li>
							<li>Go back to the settings page for the project.</li>
							<li>In the left-hand menu, click “General Settings”.</li>
							<li>Click “Edit” on the build configuration you want to trigger Intern from.</li>
							<li>In the left-hand menu, click “Triggers”.</li>
							<li>Click “Add new trigger”.</li>
							<li>Choose “Finish Build Trigger” from the drop-down.</li>
							<li>Under “Build configuration”, choose the Intern build configuration that was just created.</li>
							<li>Check “Trigger after successful build only”.</li>
							<li>Click “Save”.</li>
						</ol>
					</article>

					<article>
						<div class="a" id="customisation"></div>
						<h2 data-id="customisation">Customisation</h2>

						<div class="a half" id="custom-interfaces"></div>
						<h3 data-id="custom-interfaces">Custom interfaces</h3>

						<p>TODO</p>

						<div class="a half" id="custom-executors"></div>
						<h3 data-id="custom-executors">Custom executors</h3>

						<p>TODO</p>

						<div class="a half" id="custom-reporters"></div>
						<h3 data-id="custom-reporters">Custom reporters</h3>

						<p>TODO</p>
					</article>

					<article>
						<div class="a" id="internals"></div>
						<h2 data-id="internals">Internals</h2>

						<div class="a half" id="suite-object"></div>
						<h3 data-id="suite-object">The Suite object</h3>

						<p>TODO</p>

						<div class="a half" id="test-object"></div>
						<h3 data-id="test-object">The Test object</h3>

						<p>TODO</p>
					</article>

					<article>
						<div class="a" id="community"></div>
						<h2 data-id="community">Community</h2>

						<div class="a half" id="getting-help"></div>
						<h3 data-id="getting-help">Getting help</h3>

						<p>The Intern team wants to help people like you write tests more quickly and easily than ever before. As such, we offer two different ways you can get help with Intern:</p>

						<h4>Community support</h4>

						<p>The Intern community is available to assist you with basic questions, advice, and general guidance. There are two primary ways to get community support:</p>

						<ul>
							<li>Post on Stack Overflow using the tag <a href="http://stackoverflow.com/questions/ask?tags=intern">[intern]</a>. Please make sure to follow the <a href="http://stackoverflow.com/help/how-to-ask">Stack Overflow guidelines</a> when asking your question in order to have the greatest chance of receiving a response!</li>
							<li>Join us on IRC at <a href="irc://irc.freenode.net/intern">#intern on Freenode</a>. Please make sure to follow the rules outlined in <a href="https://rurounijones.github.io/blog/2009/03/17/how-to-ask-for-help-on-irc/">How to Ask for Help on IRC</a> when asking your question in order to have the greatest chance of receiving a response!</li>
						</ul>

						<h4>Commercial support</h4>

						<p>Some problems are too complicated, specific, time-sensitive, or confidential to be solved through free community support. In these cases, the creators of Intern, SitePen, offer <a href="http://www.sitepen.com/support/index.html">commercial support services</a> for you or your company. Commercial support has several advantages over community support:</p>

						<ul>
							<li>Guaranteed response</li>
							<li>24 hours maximum response time</li>
							<li>Priority bug fix and enhancement requests</li>
							<li>Total confidentiality for your next big idea</li>
							<li>Provides direct financial support for ongoing development of Intern</li>
						</ul>

						<p>If you aren’t sure if commercial support is right for you, we’re happy to take a few minutes to talk through your needs in greater detail. <a href="https://www.sitepen.com/site/contact.html">Get in touch</a> to schedule a time!</p>

						<div class="a half" id="contributing"></div>
						<h3 data-id="contributing">Contributing</h3>

						<p>We’re always excited to receive contributions from the community. If you think you’ve discovered a bug, want to submit a patch, or would like to request a new feature, take a look at our <a href="https://github.com/theintern/intern/blob/master/CONTRIBUTING.md">contribution guidelines on GitHub</a> to learn how you can contribute.</p>
					</article>
				</main>
			</div>
		</div>
		<script src="css/main.min.js"></script>
	</body>
</html>
